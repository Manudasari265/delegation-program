use crate::discriminator::DlpDiscriminator;
use crate::processor::process_call_handler;
use crate::{discriminator, processor};

use pinocchio_log::log;
use solana_program::account_info::AccountInfo;
use solana_program::entrypoint::ProgramResult;
use solana_program::program_error::ProgramError;
use solana_program::pubkey::Pubkey;
use solana_program::{entrypoint, msg};

entrypoint::custom_heap_default!();
entrypoint::custom_panic_default!();

/// # Safety
///
/// It's pretty close to the code generated by entrypoint!() macro, with one minor tweak to
/// support fallback branch.
#[no_mangle]
pub unsafe extern "C" fn entrypoint(input: *mut u8) -> u64 {
    const UNINIT: core::mem::MaybeUninit<pinocchio::account_info::AccountInfo> =
        core::mem::MaybeUninit::<pinocchio::account_info::AccountInfo>::uninit();
    let mut accounts = [UNINIT; { pinocchio::MAX_TX_ACCOUNTS }];

    let (program_id, count, data) =
        pinocchio::entrypoint::deserialize::<{ pinocchio::MAX_TX_ACCOUNTS }>(input, &mut accounts);
    match fast_process_instruction(
        program_id,
        core::slice::from_raw_parts(accounts.as_ptr() as _, count),
        data,
    ) {
        Some(Ok(())) => pinocchio::SUCCESS,
        Some(Err(error)) => error.into(),

        // Fallback to the slow path that does not use pinocchio SDK.
        None => slow_entrypoint(input),
    }
}

/// # Safety
///
/// It's pretty close to the code generated by entrypoint!() macro, with one difference: the
/// function name is slow_entrypoint() as opposed to entrypoint() because this is a fallback
/// entrypoint (a slow one).
pub unsafe fn slow_entrypoint(input: *mut u8) -> u64 {
    let (program_id, accounts, instruction_data) = unsafe { entrypoint::deserialize(input) };
    match slow_process_instruction(program_id, &accounts, instruction_data) {
        Ok(()) => entrypoint::SUCCESS,
        Err(error) => error.into(),
    }
}

pub fn fast_process_instruction(
    program_id: &pinocchio::pubkey::Pubkey,
    accounts: &[pinocchio::account_info::AccountInfo],
    data: &[u8],
) -> Option<pinocchio::ProgramResult> {
    if data.len() < 8 {
        return Some(Err(
            pinocchio::program_error::ProgramError::InvalidInstructionData,
        ));
    }

    let (discriminator_bytes, data) = data.split_at(8);

    let discriminator = match DlpDiscriminator::try_from(discriminator_bytes[0]) {
        Ok(discriminator) => discriminator,
        Err(_) => {
            log!("Failed to read and parse discriminator");
            return Some(Err(
                pinocchio::program_error::ProgramError::InvalidInstructionData,
            ));
        }
    };

    match discriminator {
        discriminator::DlpDiscriminator::Delegate => Some(processor::fast::process_delegate(
            program_id, accounts, data,
        )),
        discriminator::DlpDiscriminator::CommitState => Some(
            processor::fast::process_commit_state(program_id, accounts, data),
        ),
        discriminator::DlpDiscriminator::CommitStateFromBuffer => Some(
            processor::fast::process_commit_state_from_buffer(program_id, accounts, data),
        ),
        discriminator::DlpDiscriminator::Finalize => Some(processor::fast::process_finalize(
            program_id, accounts, data,
        )),
        discriminator::DlpDiscriminator::Undelegate => Some(processor::fast::process_undelegate(
            program_id, accounts, data,
        )),
        _ => None,
    }
}

pub fn slow_process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    data: &[u8],
) -> ProgramResult {
    if data.len() < 8 {
        return Err(ProgramError::InvalidInstructionData);
    }

    let (tag, data) = data.split_at(8);
    let ix = discriminator::DlpDiscriminator::try_from(tag[0])
        .or(Err(ProgramError::InvalidInstructionData))?;

    msg!("Processing instruction: {:?}", ix);
    match ix {
        discriminator::DlpDiscriminator::InitValidatorFeesVault => {
            processor::process_init_validator_fees_vault(program_id, accounts, data)?
        }
        discriminator::DlpDiscriminator::InitProtocolFeesVault => {
            processor::process_init_protocol_fees_vault(program_id, accounts, data)?
        }
        discriminator::DlpDiscriminator::ValidatorClaimFees => {
            processor::process_validator_claim_fees(program_id, accounts, data)?
        }
        discriminator::DlpDiscriminator::WhitelistValidatorForProgram => {
            processor::process_whitelist_validator_for_program(program_id, accounts, data)?
        }
        discriminator::DlpDiscriminator::TopUpEphemeralBalance => {
            processor::process_top_up_ephemeral_balance(program_id, accounts, data)?
        }
        discriminator::DlpDiscriminator::DelegateEphemeralBalance => {
            processor::process_delegate_ephemeral_balance(program_id, accounts, data)?
        }
        discriminator::DlpDiscriminator::CloseEphemeralBalance => {
            processor::process_close_ephemeral_balance(program_id, accounts, data)?
        }
        discriminator::DlpDiscriminator::ProtocolClaimFees => {
            processor::process_protocol_claim_fees(program_id, accounts, data)?
        }
        discriminator::DlpDiscriminator::CloseValidatorFeesVault => {
            processor::process_close_validator_fees_vault(program_id, accounts, data)?
        }
        discriminator::DlpDiscriminator::CallHandler => {
            process_call_handler(program_id, accounts, data)?
        }
        _ => {
            log!("PANIC: Instruction must be processed by fast_process_instruction");
            return Err(ProgramError::InvalidInstructionData);
        }
    }
    Ok(())
}
