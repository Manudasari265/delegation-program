use crate::{fast_process_instruction, slow_process_instruction};

use solana_program::entrypoint;

entrypoint::custom_heap_default!();
entrypoint::custom_panic_default!();

/// # Safety
///
/// It's pretty close to the code generated by entrypoint!() macro, with one minor tweak to
/// support fallback branch.
#[no_mangle]
pub unsafe extern "C" fn entrypoint(input: *mut u8) -> u64 {
    const UNINIT: core::mem::MaybeUninit<pinocchio::account_info::AccountInfo> =
        core::mem::MaybeUninit::<pinocchio::account_info::AccountInfo>::uninit();
    let mut accounts = [UNINIT; { pinocchio::MAX_TX_ACCOUNTS }];

    let (program_id, count, data) =
        pinocchio::entrypoint::deserialize::<{ pinocchio::MAX_TX_ACCOUNTS }>(input, &mut accounts);
    match fast_process_instruction(
        program_id,
        core::slice::from_raw_parts(accounts.as_ptr() as _, count),
        data,
    ) {
        Some(Ok(())) => pinocchio::SUCCESS,
        Some(Err(error)) => error.into(),

        // Fallback to the slow path that does not use pinocchio SDK.
        None => slow_entrypoint(input),
    }
}

/// # Safety
///
/// It's pretty close to the code generated by entrypoint!() macro, with one difference: the
/// function name is slow_entrypoint() as opposed to entrypoint() because this is a fallback
/// entrypoint (a slow one).
pub unsafe fn slow_entrypoint(input: *mut u8) -> u64 {
    let (program_id, accounts, instruction_data) = unsafe { entrypoint::deserialize(input) };
    match slow_process_instruction(program_id, &accounts, instruction_data) {
        Ok(()) => entrypoint::SUCCESS,
        Err(error) => error.into(),
    }
}
