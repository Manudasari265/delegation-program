#![allow(unexpected_cfgs)] // silence clippy for target_os solana and other solana program custom features

use crate::processor::process_call_handler;
use pinocchio_log::log;
use solana_program::{
    account_info::AccountInfo,
    declare_id,
    entrypoint::{self, ProgramResult},
    msg,
    program_error::ProgramError,
    pubkey::Pubkey,
};

use discriminator::DlpDiscriminator;

pub mod args;
pub mod consts;
mod discriminator;
pub mod error;
pub mod instruction_builder;
pub mod pda;
mod processor;
pub mod state;

#[cfg(feature = "log-cost")]
mod cu;

declare_id!("DELeGGvXpWV2fqJUhqcF5ZSYMS4JTLjteaAMARRSaeSh");

pub mod fast {
    pinocchio_pubkey::declare_id!("DELeGGvXpWV2fqJUhqcF5ZSYMS4JTLjteaAMARRSaeSh");
}

entrypoint::custom_heap_default!();
entrypoint::custom_panic_default!();

#[cfg(all(not(feature = "no-entrypoint"), feature = "solana-security-txt"))]
solana_security_txt::security_txt! {
    name: "MagicBlock Delegation Program",
    project_url: "https://magicblock.gg",
    contacts: "email:dev@magicblock.gg,twitter:@magicblock",
    policy: "https://github.com/magicblock-labs/delegation-program/blob/master/LICENSE.md",
    preferred_languages: "en",
    source_code: "https://github.com/magicblock-labs/delegation-program"
}

/// # Safety
///
/// It's pretty close to the code generated by entrypoint!() macro, with one minor tweak to
/// support fallback branch.
#[no_mangle]
pub unsafe extern "C" fn entrypoint(input: *mut u8) -> u64 {
    const UNINIT: core::mem::MaybeUninit<pinocchio::account_info::AccountInfo> =
        core::mem::MaybeUninit::<pinocchio::account_info::AccountInfo>::uninit();
    let mut accounts = [UNINIT; { pinocchio::MAX_TX_ACCOUNTS }];

    let (program_id, count, data) =
        pinocchio::entrypoint::deserialize::<{ pinocchio::MAX_TX_ACCOUNTS }>(input, &mut accounts);
    match fast_process_instruction(
        program_id,
        core::slice::from_raw_parts(accounts.as_ptr() as _, count),
        data,
    ) {
        Some(Ok(())) => pinocchio::SUCCESS,
        Some(Err(error)) => error.into(),

        // Fallback to the slow path that does not use pinocchio SDK.
        None => slow_entrypoint(input),
    }
}

/// # Safety
///
/// It's pretty close to the code generated by entrypoint!() macro, with one difference: the
/// function name is slow_entrypoint() as opposed to entrypoint() because this is a fallback
/// entrypoint (a slow one).
pub unsafe fn slow_entrypoint(input: *mut u8) -> u64 {
    let (program_id, accounts, instruction_data) = unsafe { entrypoint::deserialize(input) };
    match slow_process_instruction(program_id, &accounts, instruction_data) {
        Ok(()) => entrypoint::SUCCESS,
        Err(error) => error.into(),
    }
}

pub fn fast_process_instruction(
    program_id: &pinocchio::pubkey::Pubkey,
    accounts: &[pinocchio::account_info::AccountInfo],
    data: &[u8],
) -> Option<pinocchio::ProgramResult> {
    if data.len() < 8 {
        return Some(Err(
            pinocchio::program_error::ProgramError::InvalidInstructionData,
        ));
    }

    let (discriminator_bytes, data) = data.split_at(8);

    let discriminator = match DlpDiscriminator::try_from(discriminator_bytes[0]) {
        Ok(discriminator) => discriminator,
        Err(_) => {
            log!("Failed to read and parse discriminator");
            return Some(Err(
                pinocchio::program_error::ProgramError::InvalidInstructionData,
            ));
        }
    };

    match discriminator {
        discriminator::DlpDiscriminator::Delegate => Some(processor::fast::process_delegate(
            program_id, accounts, data,
        )),
        discriminator::DlpDiscriminator::Undelegate => Some(processor::fast::process_undelegate(
            program_id, accounts, data,
        )),
        _ => None,
    }
}

pub fn slow_process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    data: &[u8],
) -> ProgramResult {
    if program_id.ne(&id()) {
        return Err(ProgramError::IncorrectProgramId);
    }

    if data.len() < 8 {
        return Err(ProgramError::InvalidInstructionData);
    }

    let (tag, data) = data.split_at(8);
    let tag_array: [u8; 8] = tag
        .try_into()
        .map_err(|_| ProgramError::InvalidInstructionData)?;

    let ix = discriminator::DlpDiscriminator::try_from(tag_array)
        .or(Err(ProgramError::InvalidInstructionData))?;
    msg!("Processing instruction: {:?}", ix);
    match ix {
        discriminator::DlpDiscriminator::Delegate => {
            processor::process_delegate(program_id, accounts, data)?
        }
        discriminator::DlpDiscriminator::CommitState => {
            processor::process_commit_state(program_id, accounts, data)?
        }
        discriminator::DlpDiscriminator::CommitStateFromBuffer => {
            processor::process_commit_state_from_buffer(program_id, accounts, data)?
        }
        discriminator::DlpDiscriminator::Finalize => {
            processor::process_finalize(program_id, accounts, data)?
        }
        discriminator::DlpDiscriminator::Undelegate => {
            processor::process_undelegate(program_id, accounts, data)?
        }
        discriminator::DlpDiscriminator::InitValidatorFeesVault => {
            processor::process_init_validator_fees_vault(program_id, accounts, data)?
        }
        discriminator::DlpDiscriminator::InitProtocolFeesVault => {
            processor::process_init_protocol_fees_vault(program_id, accounts, data)?
        }
        discriminator::DlpDiscriminator::ValidatorClaimFees => {
            processor::process_validator_claim_fees(program_id, accounts, data)?
        }
        discriminator::DlpDiscriminator::WhitelistValidatorForProgram => {
            processor::process_whitelist_validator_for_program(program_id, accounts, data)?
        }
        discriminator::DlpDiscriminator::TopUpEphemeralBalance => {
            processor::process_top_up_ephemeral_balance(program_id, accounts, data)?
        }
        discriminator::DlpDiscriminator::DelegateEphemeralBalance => {
            processor::process_delegate_ephemeral_balance(program_id, accounts, data)?
        }
        discriminator::DlpDiscriminator::CloseEphemeralBalance => {
            processor::process_close_ephemeral_balance(program_id, accounts, data)?
        }
        discriminator::DlpDiscriminator::ProtocolClaimFees => {
            processor::process_protocol_claim_fees(program_id, accounts, data)?
        }
        discriminator::DlpDiscriminator::CloseValidatorFeesVault => {
            processor::process_close_validator_fees_vault(program_id, accounts, data)?
        }
        discriminator::DlpDiscriminator::CallHandler => {
            process_call_handler(program_id, accounts, data)?
        }
    }
    Ok(())
}
